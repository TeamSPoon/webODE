
//----------------------------------------------------
// The following code was generated by CUP v0.10j
// Mon Jan 26 11:16:19 CET 2004
//----------------------------------------------------

package es.upm.fi.dia.ontology.webode.Axiom;

import java_cup.runtime.*;
import java.lang.System;
import java.io.*;
import java.util.Hashtable;
import java.util.Vector;
import es.upm.fi.dia.ontology.webode.service.*;

/** CUP v0.10j generated parser.
  * @version Mon Jan 26 11:16:19 CET 2004
  */
public class parserRule extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parserRule() {super();}

  /** Constructor which sets the default scanner. */
  public parserRule(java_cup.runtime.Scanner s) {super(s);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\052\000\002\002\004\000\002\003\003\000\002\005" +
    "\003\000\002\005\003\000\002\005\003\000\002\005\006" +
    "\000\002\005\005\000\002\005\005\000\002\005\005\000" +
    "\002\005\005\000\002\005\007\000\002\005\007\000\002" +
    "\005\007\000\002\005\007\000\002\005\005\000\002\005" +
    "\005\000\002\005\005\000\002\005\003\000\002\004\004" +
    "\000\002\006\004\000\002\006\002\000\002\006\003\000" +
    "\002\007\006\000\002\007\004\000\002\007\006\000\002" +
    "\007\006\000\002\007\006\000\002\007\006\000\002\007" +
    "\006\000\002\007\006\000\002\007\005\000\002\007\005" +
    "\000\002\007\005\000\002\007\005\000\002\007\005\000" +
    "\002\007\005\000\002\011\003\000\002\011\005\000\002" +
    "\012\003\000\002\010\006\000\002\010\006\000\002\010" +
    "\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\145\000\004\016\004\001\002\000\030\003\020\004" +
    "\013\005\014\006\024\007\021\010\022\011\010\014\015" +
    "\020\025\032\012\033\023\001\002\000\004\002\007\001" +
    "\002\000\004\002\000\001\002\000\004\002\001\001\002" +
    "\000\004\014\145\001\002\000\024\021\131\022\125\023" +
    "\127\024\126\025\130\026\041\027\036\030\035\031\042" +
    "\001\002\000\040\002\ufffe\003\ufffe\012\ufffe\013\ufffe\015" +
    "\ufffe\017\ufffe\021\ufffe\022\ufffe\023\ufffe\024\ufffe\025\ufffe" +
    "\026\ufffe\027\ufffe\030\ufffe\031\ufffe\001\002\000\004\014" +
    "\142\001\002\000\004\014\137\001\002\000\030\003\030" +
    "\004\013\005\014\006\024\007\021\010\022\011\010\014" +
    "\015\020\123\032\052\033\053\001\002\000\006\015\117" +
    "\017\uffdd\001\002\000\004\017\114\001\002\000\026\017" +
    "\111\021\ufff0\022\ufff0\023\ufff0\024\ufff0\025\ufff0\026\ufff0" +
    "\027\ufff0\030\ufff0\031\ufff0\001\002\000\004\014\106\001" +
    "\002\000\004\014\103\001\002\000\040\002\ufffd\003\ufffd" +
    "\012\ufffd\013\ufffd\015\ufffd\017\ufffd\021\ufffd\022\ufffd\023" +
    "\ufffd\024\ufffd\025\ufffd\026\ufffd\027\ufffd\030\ufffd\031\ufffd" +
    "\001\002\000\004\014\100\001\002\000\030\003\026\014" +
    "\027\021\uffff\022\uffff\023\uffff\024\uffff\025\uffff\026\uffff" +
    "\027\uffff\030\uffff\031\uffff\001\002\000\012\002\uffea\013" +
    "\uffea\015\uffea\017\uffea\001\002\000\014\003\030\014\033" +
    "\020\032\032\012\033\023\001\002\000\040\002\ufff0\003" +
    "\ufff0\012\ufff0\013\ufff0\015\ufff0\017\ufff0\021\ufff0\022\ufff0" +
    "\023\ufff0\024\ufff0\025\ufff0\026\ufff0\027\ufff0\030\ufff0\031" +
    "\ufff0\001\002\000\004\013\077\001\002\000\042\002\uffff" +
    "\003\uffff\012\uffff\013\uffff\014\074\015\uffff\017\uffff\021" +
    "\uffff\022\uffff\023\uffff\024\uffff\025\uffff\026\uffff\027\uffff" +
    "\030\uffff\031\uffff\001\002\000\014\003\030\014\033\020" +
    "\051\032\052\033\053\001\002\000\020\003\040\012\037" +
    "\013\uffed\026\041\027\036\030\035\031\042\001\002\000" +
    "\014\003\030\014\033\020\032\032\012\033\023\001\002" +
    "\000\014\003\030\014\033\020\032\032\012\033\023\001" +
    "\002\000\014\003\030\014\033\020\032\032\012\033\023" +
    "\001\002\000\004\013\uffec\001\002\000\014\003\030\014" +
    "\033\020\032\032\012\033\023\001\002\000\014\003\030" +
    "\014\033\020\032\032\012\033\023\001\002\000\004\013" +
    "\uffef\001\002\000\040\002\ufff8\003\ufff8\012\ufff8\013\ufff8" +
    "\015\ufff8\017\ufff8\021\ufff8\022\ufff8\023\ufff8\024\ufff8\025" +
    "\ufff8\026\ufff8\027\ufff8\030\ufff8\031\ufff8\001\002\000\040" +
    "\002\ufffb\003\ufffb\012\ufffb\013\ufffb\015\ufffb\017\ufffb\021" +
    "\ufffb\022\ufffb\023\ufffb\024\ufffb\025\ufffb\026\ufffb\027\ufffb" +
    "\030\035\031\042\001\002\000\004\013\uffee\001\002\000" +
    "\040\002\ufffa\003\ufffa\012\ufffa\013\ufffa\015\ufffa\017\ufffa" +
    "\021\ufffa\022\ufffa\023\ufffa\024\ufffa\025\ufffa\026\ufffa\027" +
    "\ufffa\030\035\031\042\001\002\000\040\002\ufff9\003\ufff9" +
    "\012\ufff9\013\ufff9\015\ufff9\017\ufff9\021\ufff9\022\ufff9\023" +
    "\ufff9\024\ufff9\025\ufff9\026\ufff9\027\ufff9\030\ufff9\031\ufff9" +
    "\001\002\000\016\013\073\014\074\026\uffff\027\uffff\030" +
    "\uffff\031\uffff\001\002\000\026\013\072\021\ufffe\022\ufffe" +
    "\023\ufffe\024\ufffe\025\ufffe\026\ufffe\027\ufffe\030\ufffe\031" +
    "\ufffe\001\002\000\026\013\071\021\ufffd\022\ufffd\023\ufffd" +
    "\024\ufffd\025\ufffd\026\ufffd\027\ufffd\030\ufffd\031\ufffd\001" +
    "\002\000\012\026\057\027\056\030\055\031\060\001\002" +
    "\000\014\003\030\014\033\020\032\032\012\033\023\001" +
    "\002\000\014\003\030\014\033\020\032\032\012\033\023" +
    "\001\002\000\014\003\030\014\033\020\032\032\012\033" +
    "\023\001\002\000\014\003\030\014\033\020\032\032\012" +
    "\033\023\001\002\000\026\013\062\021\ufff8\022\ufff8\023" +
    "\ufff8\024\ufff8\025\ufff8\026\ufff8\027\ufff8\030\ufff8\031\ufff8" +
    "\001\002\000\040\002\ufff4\003\ufff4\012\ufff4\013\ufff4\015" +
    "\ufff4\017\ufff4\021\ufff4\022\ufff4\023\ufff4\024\ufff4\025\ufff4" +
    "\026\ufff4\027\ufff4\030\ufff4\031\ufff4\001\002\000\026\013" +
    "\064\021\ufffb\022\ufffb\023\ufffb\024\ufffb\025\ufffb\026\ufffb" +
    "\027\ufffb\030\035\031\042\001\002\000\040\002\ufff7\003" +
    "\ufff7\012\ufff7\013\ufff7\015\ufff7\017\ufff7\021\ufff7\022\ufff7" +
    "\023\ufff7\024\ufff7\025\ufff7\026\ufff7\027\ufff7\030\ufff7\031" +
    "\ufff7\001\002\000\026\013\066\021\ufffa\022\ufffa\023\ufffa" +
    "\024\ufffa\025\ufffa\026\ufffa\027\ufffa\030\035\031\042\001" +
    "\002\000\040\002\ufff6\003\ufff6\012\ufff6\013\ufff6\015\ufff6" +
    "\017\ufff6\021\ufff6\022\ufff6\023\ufff6\024\ufff6\025\ufff6\026" +
    "\ufff6\027\ufff6\030\ufff6\031\ufff6\001\002\000\026\013\070" +
    "\021\ufff9\022\ufff9\023\ufff9\024\ufff9\025\ufff9\026\ufff9\027" +
    "\ufff9\030\ufff9\031\ufff9\001\002\000\040\002\ufff5\003\ufff5" +
    "\012\ufff5\013\ufff5\015\ufff5\017\ufff5\021\ufff5\022\ufff5\023" +
    "\ufff5\024\ufff5\025\ufff5\026\ufff5\027\ufff5\030\ufff5\031\ufff5" +
    "\001\002\000\040\002\ufff1\003\ufff1\012\ufff1\013\ufff1\015" +
    "\ufff1\017\ufff1\021\ufff1\022\ufff1\023\ufff1\024\ufff1\025\ufff1" +
    "\026\ufff1\027\ufff1\030\ufff1\031\ufff1\001\002\000\040\002" +
    "\ufff2\003\ufff2\012\ufff2\013\ufff2\015\ufff2\017\ufff2\021\ufff2" +
    "\022\ufff2\023\ufff2\024\ufff2\025\ufff2\026\ufff2\027\ufff2\030" +
    "\ufff2\031\ufff2\001\002\000\040\002\ufff3\003\ufff3\012\ufff3" +
    "\013\ufff3\015\ufff3\017\ufff3\021\ufff3\022\ufff3\023\ufff3\024" +
    "\ufff3\025\ufff3\026\ufff3\027\ufff3\030\ufff3\031\ufff3\001\002" +
    "\000\014\003\030\014\033\020\032\032\012\033\023\001" +
    "\002\000\004\013\076\001\002\000\040\002\ufffc\003\ufffc" +
    "\012\ufffc\013\ufffc\015\ufffc\017\ufffc\021\ufffc\022\ufffc\023" +
    "\ufffc\024\ufffc\025\ufffc\026\ufffc\027\ufffc\030\ufffc\031\ufffc" +
    "\001\002\000\034\002\uffeb\013\uffeb\015\uffeb\017\uffeb\021" +
    "\ufffc\022\ufffc\023\ufffc\024\ufffc\025\ufffc\026\ufffc\027\ufffc" +
    "\030\ufffc\031\ufffc\001\002\000\014\003\030\014\033\020" +
    "\032\032\012\033\023\001\002\000\004\013\102\001\002" +
    "\000\012\002\uffe7\013\uffe7\015\uffe7\017\uffe7\001\002\000" +
    "\014\003\030\014\033\020\032\032\012\033\023\001\002" +
    "\000\004\013\105\001\002\000\012\002\uffe5\013\uffe5\015" +
    "\uffe5\017\uffe5\001\002\000\014\003\030\014\033\020\032" +
    "\032\012\033\023\001\002\000\004\013\110\001\002\000" +
    "\012\002\uffe6\013\uffe6\015\uffe6\017\uffe6\001\002\000\030" +
    "\003\030\004\013\005\014\006\024\007\021\010\022\011" +
    "\010\014\015\020\025\032\012\033\023\001\002\000\004" +
    "\002\uffd9\001\002\000\004\002\uffdb\001\002\000\030\003" +
    "\116\004\013\005\014\006\024\007\021\010\022\011\010" +
    "\014\015\020\025\032\012\033\023\001\002\000\004\002" +
    "\uffda\001\002\000\026\002\uffd8\021\ufff0\022\ufff0\023\ufff0" +
    "\024\ufff0\025\ufff0\026\ufff0\027\ufff0\030\ufff0\031\ufff0\001" +
    "\002\000\030\003\030\004\013\005\014\006\024\007\021" +
    "\010\022\011\010\014\015\020\025\032\012\033\023\001" +
    "\002\000\004\017\uffdc\001\002\000\024\021\131\022\125" +
    "\023\127\024\126\025\130\026\057\027\056\030\055\031" +
    "\060\001\002\000\004\013\124\001\002\000\032\003\026" +
    "\013\073\014\027\021\uffff\022\uffff\023\uffff\024\uffff\025" +
    "\uffff\026\uffff\027\uffff\030\uffff\031\uffff\001\002\000\012" +
    "\002\uffde\013\uffde\015\uffde\017\uffde\001\002\000\014\003" +
    "\030\014\033\020\032\032\012\033\023\001\002\000\014" +
    "\003\030\014\033\020\032\032\012\033\023\001\002\000" +
    "\014\003\030\014\033\020\032\032\012\033\023\001\002" +
    "\000\014\003\030\014\033\020\032\032\012\033\023\001" +
    "\002\000\014\003\030\014\033\020\032\032\012\033\023" +
    "\001\002\000\022\002\uffdf\013\uffdf\015\uffdf\017\uffdf\026" +
    "\041\027\036\030\035\031\042\001\002\000\022\002\uffe3" +
    "\013\uffe3\015\uffe3\017\uffe3\026\041\027\036\030\035\031" +
    "\042\001\002\000\022\002\uffe1\013\uffe1\015\uffe1\017\uffe1" +
    "\026\041\027\036\030\035\031\042\001\002\000\022\002" +
    "\uffe2\013\uffe2\015\uffe2\017\uffe2\026\041\027\036\030\035" +
    "\031\042\001\002\000\022\002\uffe0\013\uffe0\015\uffe0\017" +
    "\uffe0\026\041\027\036\030\035\031\042\001\002\000\014" +
    "\003\030\014\033\020\032\032\012\033\023\001\002\000" +
    "\004\013\141\001\002\000\012\002\uffe8\013\uffe8\015\uffe8" +
    "\017\uffe8\001\002\000\014\003\030\014\033\020\032\032" +
    "\012\033\023\001\002\000\004\013\144\001\002\000\012" +
    "\002\uffe9\013\uffe9\015\uffe9\017\uffe9\001\002\000\014\003" +
    "\030\014\033\020\032\032\012\033\023\001\002\000\004" +
    "\013\147\001\002\000\012\002\uffe4\013\uffe4\015\uffe4\017" +
    "\uffe4\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\145\000\006\003\004\010\005\001\001\000\010\005" +
    "\010\007\015\011\016\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\005\120\007\121\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\004\030\005\033\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\005\053\001\001\000\004\006\042\001\001\000\004" +
    "\005\047\001\001\000\004\005\046\001\001\000\006\004" +
    "\045\005\033\001\001\000\002\001\001\000\004\005\044" +
    "\001\001\000\004\005\043\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\005\066" +
    "\001\001\000\004\005\064\001\001\000\004\005\062\001" +
    "\001\000\004\005\060\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\004\074\005\033\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\004\100\005\033\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\004\103" +
    "\005\033\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\004\106\005\033\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\005\010\007\112\012\111\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\005\010\007\112" +
    "\012\114\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\005\010\007\015\011\117\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\005\135\001\001\000\004\005\134" +
    "\001\001\000\004\005\133\001\001\000\004\005\132\001" +
    "\001\000\004\005\131\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\004\137\005\033\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\004\142\005\033\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\004\145\005\033" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parserRule$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parserRule$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parserRule$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}




      private Vector clauses;
      private String [] prologClauses;
      protected ODEService odeService;
      protected String ontologyName;
      
      
      public String[] getClauses()
      {
        CTree elemento=null;
        int contador=0;
        int longitud=clauses.size();
        String [] result=new String[longitud];

        while (contador<longitud)
        {

          elemento=(CTree)clauses.elementAt(contador);
          result[contador]=Utility.transforma_string(elemento);
          contador++;
        }
        return result;


      }
      public String[] getPrologClauses()
      {
        return prologClauses;

      }
      private Vector errors;
      public parserRule(java_cup.runtime.Scanner s, ODEService odeService, String ont) {
        super(s);
        this.odeService=odeService;
        this.ontologyName=ont;
        errors=new Vector();    
      }

    

      public void report_error(String message, Object info)
          {
        
            errors.add(message);
        if (info instanceof Symbol)
          if (((Symbol)info).left != -1)
            errors.add(" at character " + ((Symbol)info).left +   " of input");
          else ;
            else ;

        
          }
      public void finalizado(CTree arbol)throws AxiomException
      {
        if (errors.isEmpty()){
          
          
          Utility.pinta_formula(arbol);
          clauses=Utility.ObternerClausulaHorn(arbol);
          prologClauses=Utility.TraducirProlog(clauses);
          

        }else{
          throw new AxiomException(errors);
        }
  
      }
      public void report_fatal_error(String   message, Object   info)  throws AxiomException
          {

            /* stop parsing (not really necessary since we throw an exception, but) */
            done_parsing();

            /* use the normal error message reporting to put out the message */
            report_error("Expected \")\" \",\"  or \".\" ", info);
        report_error("------------------------------","");

            /* throw an exception */
            throw new AxiomException(errors);      
      }


  
}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parserRule$actions {
  private final parserRule parser;

  /** Constructor */
  CUP$parserRule$actions(parserRule parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parserRule$do_action(
    int                        CUP$parserRule$act_num,
    java_cup.runtime.lr_parser CUP$parserRule$parser,
    java.util.Stack            CUP$parserRule$stack,
    int                        CUP$parserRule$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parserRule$result;

      /* select the action based on the action number */
      switch (CUP$parserRule$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // regla ::= IF antecedente THEN error 
            {
              CAtributo RESULT = null;
		int antleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int antright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo ant = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		
      RESULT=new CAtributo();
      RESULT.arbol=new CTree();
      RESULT.arbol.Add(ant.arbol,"or",CNodeType.NODO_OR,ant.arbol);
      parser.report_error("Error: consequent","");
      parser.report_error("Malformed consequent","");
      parser.report_error("------------------------------","");



    
              CUP$parserRule$result = new java_cup.runtime.Symbol(6/*regla*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // regla ::= IF error THEN consecuente 
            {
              CAtributo RESULT = null;
		int con1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int con1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo con1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo();
      RESULT.arbol=new CTree();
      RESULT.arbol.Add(con1.arbol,"or",CNodeType.NODO_OR,con1.arbol);
      parser.report_error("Error: antecedent","");
      parser.report_error("Malformed antecedent","");
      parser.report_error("------------------------------","");



    
              CUP$parserRule$result = new java_cup.runtime.Symbol(6/*regla*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // regla ::= IF antecedente THEN consecuente 
            {
              CAtributo RESULT = null;
		int antleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int antright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo ant = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int conleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int conright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo con = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
            RESULT=new CAtributo();
      RESULT.arbol=new CTree();

    RESULT.arbol.Add(ant.arbol,"or",CNodeType.NODO_OR,con.arbol);


    
              CUP$parserRule$result = new java_cup.runtime.Symbol(6/*regla*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // consecuente ::= atomo 
            {
              CAtributo RESULT = null;
		int atleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int atright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo at = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo();
      RESULT.arbol=new CTree();
      
      
      RESULT.arbol.Add(null,at.codigo,CNodeType.NODO_HOJA,null);
      RESULT.arbol.prolog=at.prolog;
      RESULT.arbol.prolog=RESULT.arbol.prolog.replace('$', ' '); 
      RESULT.arbol.prolog=RESULT.arbol.prolog.replace('~', ' ');
      
      


      

    
              CUP$parserRule$result = new java_cup.runtime.Symbol(8/*consecuente*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // antecedente ::= atomo AND antecedente 
            {
              CAtributo RESULT = null;
		int atleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int atright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo at = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int antleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int antright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo ant = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo();
      RESULT.arbol=new CTree();
      
      at.arbol=new CTree();

  /******cambiado estollllllllll**********/    
      CTree aux=new CTree();
      aux.Add(null,at.codigo,CNodeType.NODO_HOJA,null);
      aux.prolog=at.prolog;
      aux.prolog=aux.prolog.replace('$', ' '); 
      aux.prolog=aux.prolog.replace('~', ' ');
      
      at.arbol.Add(aux,"not",CNodeType.NODO_NOT);
      RESULT.arbol.Add(at.arbol,"or",CNodeType.NODO_OR,ant.arbol);


    
              CUP$parserRule$result = new java_cup.runtime.Symbol(7/*antecedente*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // antecedente ::= atomo 
            {
              CAtributo RESULT = null;
		int atleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int atright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo at = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		

      RESULT=new CAtributo();
      RESULT.arbol=new CTree();
      
      at.arbol=new CTree();

      at.arbol.Add(null,at.codigo,CNodeType.NODO_HOJA,null);
      at.arbol.prolog=at.prolog;
      RESULT.arbol.Add(at.arbol,"not",CNodeType.NODO_NOT);
      at.arbol.prolog=at.arbol.prolog.replace('$', ' '); 
      at.arbol.prolog=at.arbol.prolog.replace('~', ' ');
      

    
              CUP$parserRule$result = new java_cup.runtime.Symbol(7/*antecedente*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // atomo ::= PARENABIERTO atomo PARENCERRADO 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
            RESULT.codigo= "(" + term1.codigo + ")";
      RESULT.type=term1.type;
      RESULT.prolog=term1.prolog;

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // atomo ::= termino IGUAL termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
            RESULT.codigo=term1.codigo + "=" + term2.codigo;
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;

      if (term1.type!=term2.type)
      {
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't compare " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("operator = cannot be applied with different types","");
        parser.report_error("------------------------------","");



      }
    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // atomo ::= termino MENORIGUAL termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
            RESULT.codigo=term1.codigo + "<=" + term2.codigo;
      RESULT.prolog=RESULT.codigo;

      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.BOOLEAN;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't compare " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");


      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // atomo ::= termino MAYORIGUAL termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
            RESULT.codigo=term1.codigo + ">=" + term2.codigo;
      RESULT.prolog=RESULT.codigo;
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.BOOLEAN;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't compare " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");


      }
    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // atomo ::= termino MENOR termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
            RESULT.codigo=term1.codigo + "<" + term2.codigo;
      RESULT.prolog=RESULT.codigo;

      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.BOOLEAN;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't compare " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");


      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // atomo ::= termino MAYOR termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
            RESULT.codigo=term1.codigo + ">" + term2.codigo;
      RESULT.prolog=RESULT.codigo;

      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.BOOLEAN;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't compare " + term1.codigo + " and " + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");


      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // atomo ::= INSTRANSITIVE PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
          RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;      

      if (list.nterminos != 2){

          parser.report_error("Error:","");
          parser.report_error(id.m_text + " must to have two terms","");
          parser.report_error("------------------------------","");
      }

    

               
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // atomo ::= TRANSITIVE PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
          RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;      

      if (list.nterminos != 2){

          parser.report_error("Error:","");
          parser.report_error(id.m_text + " must to have two terms","");
          parser.report_error("------------------------------","");
      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // atomo ::= EXHAUSTIVE PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
            RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;          
      

      if (list.nterminos != 2){

          parser.report_error("Error:","");
          parser.report_error(id.m_text + " must to have two terms","");
          parser.report_error("------------------------------","");
      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // atomo ::= DISJOINT PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
          RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;      

      if (list.nterminos != 2){

          parser.report_error("Error:","");
          parser.report_error(id.m_text + " must to have two terms","");
          parser.report_error("------------------------------","");
      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // atomo ::= NOT_SUBCLASS PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
          RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;      

      if (list.nterminos != 2){

          parser.report_error("Error:","");
          parser.report_error(id.m_text + " must to have two terms","");
          parser.report_error("------------------------------","");
      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // atomo ::= SUBCLASS PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
          RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=RESULT.codigo;          
      

      if (list.nterminos != 2){

          parser.report_error("Error:","");
          parser.report_error(id.m_text + " must to have two terms","");
          parser.report_error("------------------------------","");
      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // atomo ::= IDENTIFICADOR error 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
    
      RESULT=new CAtributo(); 
          RESULT.codigo="error";
      RESULT.type=AxiomConstant.ERROR;
      RESULT.prolog="error";
      parser.report_error("Error: Malformed term list of "+id.m_text,"");
      parser.report_error("  expected  \")\"  \",\"  or \".\" ","");
      parser.report_error("------------------------------","");



              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // atomo ::= IDENTIFICADOR PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo();
       
      RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.BOOLEAN;
      RESULT.prolog=null;          
      if (list.nterminos==1){

	Term term=parser.odeService.getTerm(parser.ontologyName,id.m_text);
        if(term!=null) {
          RESULT.prolog="instance_of("+list.terminos.elementAt(0)+","+ id.m_text+")";
          RESULT.prolog=RESULT.prolog.replace(' ','_');
          RESULT.prolog=RESULT.prolog.toLowerCase();
          
          if (term.type != TermTypes.CONCEPT)
          {
            
            parser.report_error("Error:","");
            parser.report_error(id.m_text + " must be a concept","");
            parser.report_error("------------------------------","");
                      
          }  
          

        }
        else {
          
            parser.report_error("Error:","");
            parser.report_error(id.m_text + " doesn't exist in the ontology","");
            parser.report_error("------------------------------","");
          

        }


      }else if (list.nterminos==2){

        try{

          boolean encontrado=false;
          int i=0;

          TermRelation [] aux=parser.odeService.getTermRelations(parser.ontologyName, true);
          while(aux!=null && !encontrado && i<aux.length)
          {
            encontrado=aux[i].name.equals(id.m_text);
            
            i++;
          }
        
          i=0;
          Term [] aux1=parser.odeService.getTerms(parser.ontologyName,new int [] {TermTypes.INSTANCE_ATTRIBUTE});
          while(aux1!=null && !encontrado && i<aux1.length)
          {
            encontrado=aux1[i].term.equals(id.m_text);
            
            i++;
          }

          i=0;
          aux1=parser.odeService.getTerms(parser.ontologyName,new int [] {TermTypes.CLASS_ATTRIBUTE});
          while(aux1!=null && !encontrado && i<aux1.length)
          {
            encontrado=aux1[i].term.equals(id.m_text);

            i++;
          }

          if ( !encontrado )
            {
            parser.report_error("Error:","");
            parser.report_error(id.m_text + " must be a attribute or a relation","");
            parser.report_error("------------------------------","");
          }else{

            RESULT.prolog="value_facet_of(" + (String)list.terminos.elementAt(0) + ",value,"+ id.m_text+ "," + list.terminos.elementAt(1)+")";
            RESULT.prolog=RESULT.prolog.replace(' ','_');
            RESULT.prolog=RESULT.prolog.toLowerCase();
          
          }    
        

        }catch (NullPointerException e){
            parser.report_error("Error:","");
            parser.report_error(id.m_text + " doesn't exist in the ontology","");
            parser.report_error("------------------------------","");


        }
        
    
          
      }else{
          parser.report_error("Error:","");
          parser.report_error(id.m_text + " cannot have three or more terms","");
          parser.report_error("------------------------------","");


      }
    


              
              CUP$parserRule$result = new java_cup.runtime.Symbol(5/*atomo*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // resto_lista_terminos ::= error 
            {
              CAtributo RESULT = null;
		int errleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
    
      RESULT=new CAtributo(); 
          RESULT.codigo="error";
      RESULT.type=AxiomConstant.ERROR;
      RESULT.terminos=null;
      parser.report_error("Error: Malformed term list ","");
      parser.report_error("  expected  \")\"  \",\"  or \".\" ","");
      parser.report_error("------------------------------","");



              
              CUP$parserRule$result = new java_cup.runtime.Symbol(4/*resto_lista_terminos*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // resto_lista_terminos ::= 
            {
              CAtributo RESULT = null;
		
    
          RESULT=new CAtributo();
          RESULT.codigo="";
          RESULT.nterminos=0;
          RESULT.terminos=new Vector();
          
              CUP$parserRule$result = new java_cup.runtime.Symbol(4/*resto_lista_terminos*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // resto_lista_terminos ::= COMA lista_terminos 
            {
              CAtributo RESULT = null;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
              
          RESULT=new CAtributo();
          RESULT.codigo= "," + list.codigo;
          RESULT.nterminos=list.nterminos;
          RESULT.terminos=list.terminos;
    
          
              CUP$parserRule$result = new java_cup.runtime.Symbol(4/*resto_lista_terminos*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // lista_terminos ::= termino resto_lista_terminos 
            {
              CAtributo RESULT = null;
		int termleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int termright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo term = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		int restleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int restright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo rest = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
        
        RESULT=new CAtributo();
        RESULT.codigo=term.codigo + rest.codigo;
        RESULT.nterminos=rest.nterminos+1;
        RESULT.terminos=rest.terminos;
        RESULT.terminos.addElement(term.codigo);



    
        
              CUP$parserRule$result = new java_cup.runtime.Symbol(2/*lista_terminos*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // termino ::= error 
            {
              CAtributo RESULT = null;
		int errleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
    
      RESULT=new CAtributo(); 
          RESULT.codigo="error";
      RESULT.type=AxiomConstant.ERROR;
      parser.report_error("Error: Malformed term  ","");
      parser.report_error("  expected  \")\"  \",\"  or \".\" ","");
      parser.report_error("------------------------------","");


              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // termino ::= PARENABIERTO NUMEROENTERO PARENCERRADO 
            {
              CAtributo RESULT = null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		Yytoken num = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo= "(" + num.m_text + ")";
      RESULT.type=AxiomConstant.NUMBER;

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // termino ::= PARENABIERTO NUMEROREAL PARENCERRADO 
            {
              CAtributo RESULT = null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		Yytoken num = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo="(" + num.m_text + ")";
      RESULT.type=AxiomConstant.NUMBER;


    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // termino ::= PARENABIERTO IDENTIFICADOR PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 

      
      Term term=parser.odeService.getTerm(parser.ontologyName,id.m_text);
      if(term!=null) {
        if (term.type!=TermTypes.CONSTANT)
        {
          //esta en la ontologia pero nos da igual
          //parser.report_error("Error:","");
          //parser.report_error(id.m_text +" is a term of the ontology, please use other name","");
          RESULT.type=AxiomConstant.NUMBER;
          RESULT.codigo= "$" + id.m_text + "~" ;

        }else{
          /*no hacemos nada es una constante*/
          RESULT.codigo= id.m_text ;
          int type=parser.odeService.getConstant(parser.ontologyName,id.m_text).valueType;
          if (type==ValueTypes.CARDINAL || type==ValueTypes.FLOAT || type==ValueTypes.INTEGER || type==ValueTypes.RANGE){
            RESULT.type=AxiomConstant.NUMBER;
          } 
        }    

      }
      else {
        /*marcamos que es una variable*/
        RESULT.type=AxiomConstant.NUMBER;
        RESULT.codigo= "$" + id.m_text + "~" ;
      }


    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // termino ::= PARENABIERTO termino DIVISION termino PARENCERRADO 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo= "(" + term1.codigo + "/" + term2.codigo + ")";
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't divide " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");


      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-4)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // termino ::= PARENABIERTO termino MULTIPLICACION termino PARENCERRADO 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo= "(" + term1.codigo + "*" + term2.codigo + ")";
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't multiply " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");



      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-4)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // termino ::= PARENABIERTO termino RESTA termino PARENCERRADO 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo= "(" + term1.codigo + "-" + term2.codigo + ")";
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't subtract " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");



      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-4)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // termino ::= PARENABIERTO termino SUMA termino PARENCERRADO 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo= "(" + term1.codigo + "+" + term2.codigo + ")";
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't add " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");



      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-4)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // termino ::= termino DIVISION termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo=term1.codigo + "/" + term2.codigo;
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't divide " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");


      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // termino ::= termino MULTIPLICACION termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo=term1.codigo + "*" + term2.codigo;
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't multiply " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");



      }
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // termino ::= termino RESTA termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo=term1.codigo + "-" + term2.codigo;
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't subtract " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");



      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // termino ::= termino SUMA termino 
            {
              CAtributo RESULT = null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).right;
		CAtributo term1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo term2 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo=term1.codigo + "+" + term2.codigo;
      if ( (term1.type==AxiomConstant.NUMBER || term1.type==AxiomConstant.FUNCTION)  && (term2.type==AxiomConstant.NUMBER || term2.type==AxiomConstant.FUNCTION))
      {
        RESULT.type=AxiomConstant.NUMBER;
      }else{
        RESULT.type=AxiomConstant.ERROR;
        parser.report_error("Error: Couldn't add " + term1.codigo + "and" + term2.codigo,"");
        parser.report_error("  they aren't numerical values","");
        parser.report_error("------------------------------","");

      }

    
              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-2)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // termino ::= IDENTIFICADOR PARENABIERTO lista_terminos PARENCERRADO 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo list = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		
    
      RESULT=new CAtributo(); 
          RESULT.codigo=id.m_text + "(" + list.codigo + ")";
      RESULT.type=AxiomConstant.FUNCTION;
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-3)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // termino ::= NUMEROENTERO 
            {
              CAtributo RESULT = null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		Yytoken num = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo=num.m_text;
      RESULT.type=AxiomConstant.NUMBER;
    

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // termino ::= NUMEROREAL 
            {
              CAtributo RESULT = null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		Yytoken num = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
      RESULT=new CAtributo(); 
          RESULT.codigo=num.m_text;
      RESULT.type=AxiomConstant.NUMBER;
      
               
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // termino ::= IDENTIFICADOR 
            {
              CAtributo RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		Yytoken id = (Yytoken)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		

      
      RESULT=new CAtributo(); 
  
      Term term=parser.odeService.getTerm(parser.ontologyName,id.m_text);
      if(term!=null) {
        if (term.type!=TermTypes.CONSTANT)
        {
          //esta en la ontologia pero nos da igual
          //parser.report_error("Error:","");
          //parser.report_error(id.m_text +" is a term of the ontology, please use other name","");
          RESULT.type=AxiomConstant.NUMBER;
          RESULT.codigo= "$" + id.m_text + "~" ;

        }else{
          /*no hacemos nada es una constante*/
          RESULT.codigo= id.m_text ;
          int type=parser.odeService.getConstant(parser.ontologyName,id.m_text).valueType;
          if (type==ValueTypes.CARDINAL || type==ValueTypes.FLOAT || type==ValueTypes.INTEGER || type==ValueTypes.RANGE){
            RESULT.type=AxiomConstant.NUMBER;
          } 
        }    

      }
      else {
        /*marcamos que es una variable*/
        RESULT.type=AxiomConstant.NUMBER;
        RESULT.codigo= "$" + id.m_text + "~" ;
      }
      
      

              
              CUP$parserRule$result = new java_cup.runtime.Symbol(3/*termino*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // inicio ::= regla 
            {
              CAtributo RESULT = null;
		int f1left = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left;
		int f1right = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right;
		CAtributo f1 = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).value;
		
    
    
    RESULT=new CAtributo();

    RESULT.arbol=f1.arbol;
  
    try{

      parser.finalizado(f1.arbol);

    }catch (AxiomException e){
      
      throw e;

      
    }

    
    
              CUP$parserRule$result = new java_cup.runtime.Symbol(1/*inicio*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          return CUP$parserRule$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= inicio EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).right;
		CAtributo start_val = (CAtributo)((java_cup.runtime.Symbol) CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).value;
		RESULT = start_val;
              CUP$parserRule$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-1)).left, ((java_cup.runtime.Symbol)CUP$parserRule$stack.elementAt(CUP$parserRule$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$parserRule$parser.done_parsing();
          return CUP$parserRule$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

